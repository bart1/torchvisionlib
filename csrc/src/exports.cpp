// Generated by using torchexport::export() -> do not edit by hand
#include "torchvisionlib/torchvisionlib.h"
#include <lantern/types.h>
#include "torchvisionlib/torchvisionlib_types.h"
void * p_torchvisionlib_last_error = NULL;

TORCHVISIONLIB_API void* torchvisionlib_last_error()
{
  return p_torchvisionlib_last_error;
}

TORCHVISIONLIB_API void torchvisionlib_last_error_clear()
{
  p_torchvisionlib_last_error = NULL;
}

torch::Tensor vision_ops_nms (torch::Tensor dets, torch::Tensor scores, double iou_threshold);
TORCHVISIONLIB_API void* _vision_ops_nms (void* dets, void* scores, double iou_threshold) {
  try {
    return  make_raw::Tensor(vision_ops_nms(from_raw::Tensor(dets), from_raw::Tensor(scores), iou_threshold));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor vision_ops_deform_conv2d (torch::Tensor input, torch::Tensor weight, torch::Tensor offset, torch::Tensor mask, torch::Tensor bias, std::int64_t stride_h, std::int64_t stride_w, std::int64_t pad_h, std::int64_t pad_w, std::int64_t dilation_h, std::int64_t dilation_w, std::int64_t groups, std::int64_t offset_groups, bool use_mask);
TORCHVISIONLIB_API void* _vision_ops_deform_conv2d (void* input, void* weight, void* offset, void* mask, void* bias, std::int64_t stride_h, std::int64_t stride_w, std::int64_t pad_h, std::int64_t pad_w, std::int64_t dilation_h, std::int64_t dilation_w, std::int64_t groups, std::int64_t offset_groups, bool use_mask) {
  try {
    return  make_raw::Tensor(vision_ops_deform_conv2d(from_raw::Tensor(input), from_raw::Tensor(weight), from_raw::Tensor(offset), from_raw::Tensor(mask), from_raw::Tensor(bias), stride_h, stride_w, pad_h, pad_w, dilation_h, dilation_w, groups, offset_groups, use_mask));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return (void*) NULL;
}
tensor_pair vision_ops_ps_roi_align (torch::Tensor input, torch::Tensor rois, double spatial_scale, int64_t pooled_height, int64_t pooled_width, int64_t sampling_ratio);
TORCHVISIONLIB_API void* _vision_ops_ps_roi_align (void* input, void* rois, double spatial_scale, int64_t pooled_height, int64_t pooled_width, int64_t sampling_ratio) {
  try {
    return  make_raw::TensorPair(vision_ops_ps_roi_align(from_raw::Tensor(input), from_raw::Tensor(rois), spatial_scale, pooled_height, pooled_width, sampling_ratio));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return (void*) NULL;
}
tensor_pair vision_ops_ps_roi_pool (torch::Tensor input, torch::Tensor rois, double spatial_scale, int64_t pooled_height, int64_t pooled_width);
TORCHVISIONLIB_API void* _vision_ops_ps_roi_pool (void* input, void* rois, double spatial_scale, int64_t pooled_height, int64_t pooled_width) {
  try {
    return  make_raw::TensorPair(vision_ops_ps_roi_pool(from_raw::Tensor(input), from_raw::Tensor(rois), spatial_scale, pooled_height, pooled_width));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor vision_ops_roi_align (torch::Tensor input, torch::Tensor rois, double spatial_scale, int64_t pooled_height, int64_t pooled_width, int64_t sampling_ratio, bool aligned);
TORCHVISIONLIB_API void* _vision_ops_roi_align (void* input, void* rois, double spatial_scale, int64_t pooled_height, int64_t pooled_width, int64_t sampling_ratio, bool aligned) {
  try {
    return  make_raw::Tensor(vision_ops_roi_align(from_raw::Tensor(input), from_raw::Tensor(rois), spatial_scale, pooled_height, pooled_width, sampling_ratio, aligned));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return (void*) NULL;
}
tensor_pair vision_ops_roi_pool (torch::Tensor input, torch::Tensor rois, double spatial_scale, int64_t pooled_height, int64_t pooled_width);
TORCHVISIONLIB_API void* _vision_ops_roi_pool (void* input, void* rois, double spatial_scale, int64_t pooled_height, int64_t pooled_width) {
  try {
    return  make_raw::TensorPair(vision_ops_roi_pool(from_raw::Tensor(input), from_raw::Tensor(rois), spatial_scale, pooled_height, pooled_width));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return (void*) NULL;
}
int test (void* path);
TORCHVISIONLIB_API int _test (void* path) {
  try {
    return  (test(path));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return 10;
}
void delete_tensor_pair (void* x);
TORCHVISIONLIB_API void _delete_tensor_pair (void* x) {
  try {
     (delete_tensor_pair(x));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  
}
torch::Tensor tensor_pair_get_first (tensor_pair x);
TORCHVISIONLIB_API void* _tensor_pair_get_first (void* x) {
  try {
    return  make_raw::Tensor(tensor_pair_get_first(from_raw::TensorPair(x)));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return (void*) NULL;
}
torch::Tensor tensor_pair_get_second (tensor_pair x);
TORCHVISIONLIB_API void* _tensor_pair_get_second (void* x) {
  try {
    return  make_raw::Tensor(tensor_pair_get_second(from_raw::TensorPair(x)));
  } TORCHVISIONLIB_HANDLE_EXCEPTION
  return (void*) NULL;
}
